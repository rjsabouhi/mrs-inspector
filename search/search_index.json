{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"MRS-Inspector","text":"<p>A lightweight tracing and reasoning-structure capture utility.</p> <p>This package provides:</p> <ul> <li>Structured state logging  </li> <li>Parent\u2013child call relationships  </li> <li>Phase markers  </li> <li>JSON trace export  </li> <li>Optional graph generation  </li> </ul> <p>Refer to the Installation and Usage pages to begin.</p>"},{"location":"api_reference/","title":"API Reference","text":"<p>This document provides the complete public API for MRS-Inspector.</p>"},{"location":"api_reference/#inspector","title":"Inspector","text":"<p>The core entry point for tracing execution.</p> <pre><code>from mrs_inspector import Inspector\n\ninspector = Inspector()\n</code></pre>"},{"location":"api_reference/#inspectfn-args-kwargs-result-trace","title":"inspect(fn, *args, kwargs) \u2192 (result, Trace)**","text":"<p>Executes the function while recording a full reasoning trace.</p> <pre><code>result, trace = inspector.inspect(fn, *args, **kwargs)\n</code></pre> <p>Captures:</p> <ul> <li>function entry/exit  </li> <li>nested calls  </li> <li>arguments + return values  </li> <li>timing metadata  </li> <li>exceptions (if thrown)  </li> </ul>"},{"location":"api_reference/#decorator-inspectorwrap","title":"Decorator: <code>@inspector.wrap</code>","text":"<p>Wraps a function so every call is automatically traced.</p> <pre><code>@inspector.wrap\ndef step(x):\n    return x * 2\n</code></pre> <p>Works for deeply nested calls and pipelines.</p>"},{"location":"api_reference/#trace-object","title":"Trace Object","text":"<p><code>Trace</code> represents the full execution history.</p>"},{"location":"api_reference/#tracesavepath-str","title":"trace.save(path: str)","text":"<p>Exports the trace to JSON.</p> <pre><code>trace.save(\"trace.json\")\n</code></pre> <p>Output includes call tree, steps, timing, and exception details.</p>"},{"location":"api_reference/#graphbuilder","title":"GraphBuilder","text":"<p>Optional utility to turn a trace into a PNG call graph.</p> <pre><code>from mrs_inspector.graph import GraphBuilder\n</code></pre>"},{"location":"api_reference/#graphbuilderbuildtrace","title":"GraphBuilder().build(trace)","text":"<p>Converts a trace into a directed graph structure.</p>"},{"location":"api_reference/#graphbuildersave_pngpath-str","title":"GraphBuilder().save_png(path: str)","text":"<p>Renders the graph to an image file.</p> <pre><code>gb = GraphBuilder()\ng = gb.build(trace)\ngb.save_png(\"graph.png\")\n</code></pre> <p>Uses <code>networkx</code> and <code>matplotlib</code> under the hood.</p>"},{"location":"api_reference/#exceptions","title":"Exceptions","text":"<p>All exceptions raised during execution are captured and stored in the trace:</p> <ul> <li>exception type  </li> <li>message  </li> <li>call context  </li> </ul> <p>They never crash tracing unless explicitly re-raised by user code.</p>"},{"location":"api_reference/#modules","title":"Modules","text":""},{"location":"api_reference/#mrs_inspectorstate","title":"<code>mrs_inspector.state</code>","text":"<p>Internal state container for function call records.</p>"},{"location":"api_reference/#mrs_inspectortrace","title":"<code>mrs_inspector.trace</code>","text":"<p>Implements the <code>Trace</code> class and JSON export.</p>"},{"location":"api_reference/#mrs_inspectorgraph","title":"<code>mrs_inspector.graph</code>","text":"<p>GraphBuilder and visualization helpers.</p> <p>End of API specification.</p>"},{"location":"basic_trace/","title":"Basic Trace Example","text":"<p>This example shows the simplest use of MRS-Inspector: capturing a trace of a function execution and exporting it to JSON.</p>"},{"location":"basic_trace/#example-tracing-a-simple-function","title":"Example: Tracing a Simple Function","text":"<pre><code>from mrs_inspector import Inspector\n\ndef main():\n    return 42\n\ninspector = Inspector()\n\n# Run with tracing enabled\nresult, trace = inspector.inspect(main)\n\n# Save the full execution trace\ntrace.save(\"basic_trace.json\")\n\nprint(\"Result:\", result)\nprint(\"Trace saved to basic_trace.json\")\n</code></pre>"},{"location":"basic_trace/#what-you-get","title":"What You Get","text":"<p>The generated <code>basic_trace.json</code> includes:</p> <ul> <li>function entry and exit  </li> <li>timing data  </li> <li>return values  </li> <li>full call record  </li> <li>structure suitable for graph building or custom inspection  </li> </ul> <p>This is the minimal workflow for using the inspector.</p>"},{"location":"custom_modules/","title":"Custom Modules Example","text":"<p>MRS-Inspector is intentionally unopinionated: you can build your own mini-modules, steps, or reasoning units, and the inspector will trace them exactly as they execute.</p> <p>This example shows how to combine multiple custom functions into a composed workflow while capturing a unified trace.</p>"},{"location":"custom_modules/#example-custom-steps-mini-modules","title":"Example: Custom Steps / Mini-Modules","text":"<pre><code>from mrs_inspector import Inspector\n\n# Define your own reasoning steps\ndef step_a():\n    return \"a\"\n\ndef step_b(x):\n    return f\"{x} + b\"\n\ninspector = Inspector()\n\n# Compose your steps into a workflow\ndef workflow():\n    return step_b(step_a())\n\n# Inspect and capture the full trace\nresult, trace = inspector.inspect(workflow)\n\ntrace.save(\"custom_modules_trace.json\")\n\nprint(\"Result:\", result)\nprint(\"Trace saved to custom_modules_trace.json\")\n</code></pre>"},{"location":"custom_modules/#what-this-demonstrates","title":"What This Demonstrates","text":"<ul> <li>You can create arbitrary functions (\"modules\") and chain them freely.  </li> <li>Every step \u2014 call, input, output, timing \u2014 is captured automatically.  </li> <li>The exported trace is fully compatible with graph building, manual inspection, or custom visualization.</li> </ul> <p>This pattern scales naturally to larger reasoning systems and nested pipelines.</p>"},{"location":"graph_output/","title":"Graph Output Example","text":"<p>MRS-Inspector can render a visual call graph from any captured trace. This example shows how to generate the trace, build the graph, and export it as a PNG.</p>"},{"location":"graph_output/#example-producing-a-graph-image","title":"Example: Producing a Graph Image","text":"<pre><code>from mrs_inspector import Inspector\nfrom mrs_inspector.graph import GraphBuilder\n\ndef main():\n    return \"done\"\n\n# Step 1 \u2014 capture trace\ninspector = Inspector()\nresult, trace = inspector.inspect(main)\n\n# Step 2 \u2014 build graph structure\ngb = GraphBuilder()\ngraph = gb.build(trace)\n\n# Step 3 \u2014 export to PNG\ngb.save_png(\"graph.png\")\n\nprint(\"Trace result:\", result)\nprint(\"Graph image written to graph.png\")\n</code></pre>"},{"location":"graph_output/#what-this-demonstrates","title":"What This Demonstrates","text":"<ul> <li>You can generate a call graph from any inspected workflow.  </li> <li>The PNG output shows:</li> <li>nodes for functions / call steps  </li> <li>edges for execution flow  </li> <li>optional metadata encoded in the JSON trace  </li> <li>This is ideal for debugging, documentation, or visual reasoning analysis.</li> </ul> <p>For full customization options, see the GraphBuilder class in the API reference.</p>"},{"location":"installation/","title":"Installation","text":""},{"location":"installation/#installation","title":"Installation","text":"<p>```bash pip install mrs-inspector</p>"},{"location":"usage/","title":"Usage Guide","text":"<p>This guide shows how to use MRS-Inspector to trace functions, capture reasoning flow, and produce structured output.</p>"},{"location":"usage/#basic-inspection","title":"Basic Inspection","text":"<pre><code>from mrs_inspector import Inspector\n\ninspector = Inspector()\n\ndef main():\n    return \"ok\"\n\nresult, trace = inspector.inspect(main)\ntrace.save(\"trace.json\")\n</code></pre> <p>This produces a JSON trace containing:</p> <ul> <li>function entry  </li> <li>nested calls  </li> <li>inputs/outputs  </li> <li>exceptions (if any)  </li> <li>timing metadata  </li> </ul>"},{"location":"usage/#inspecting-a-function-with-arguments","title":"Inspecting a Function With Arguments","text":"<pre><code>from mrs_inspector import Inspector\n\ninspector = Inspector()\n\ndef add(a, b):\n    return a + b\n\nresult, trace = inspector.inspect(add, 2, 3)\ntrace.save(\"add_trace.json\")\n</code></pre>"},{"location":"usage/#using-the-decorator-form","title":"Using the Decorator Form","text":"<pre><code>from mrs_inspector import Inspector\n\ninspector = Inspector()\n\n@inspector.wrap\ndef multiply(x, y):\n    return x * y\n\nresult, trace = inspector.inspect(lambda: multiply(4, 5))\ntrace.save(\"multiply_trace.json\")\n</code></pre>"},{"location":"usage/#capturing-exceptions","title":"Capturing Exceptions","text":"<pre><code>from mrs_inspector import Inspector\n\ninspector = Inspector()\n\n@inspector.wrap\ndef explode(x):\n    return 10 / x   # ZeroDivisionError when x = 0\n\nresult, trace = inspector.inspect(lambda: explode(0))\ntrace.save(\"exception_trace.json\")\n</code></pre> <p>The trace includes a full exception record: message, type, and call context.</p>"},{"location":"usage/#next-steps","title":"Next Steps","text":"<ul> <li>See API Reference for details on Inspector, Trace, and graph utilities.  </li> <li>Visit Examples for full workflows.</li> </ul>"}]}